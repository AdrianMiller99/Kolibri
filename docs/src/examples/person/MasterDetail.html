<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="shortcut icon" type="image/png" href="../../../img/logo/logo-60x54.png"/>
    <link rel="stylesheet"                     href="./instantUpdateProjector.css">
    <title>Person Master-Detail View</title>
    <style>
        section {
            max-width:  40em;
            margin:     1em auto 4em auto;
        }
    </style> <!--to be filled dynamically-->
</head>
<body>

<div class="card">
    <h1>Person List</h1>

    <div class="holder" id="masterContainer">
        <button id="plus" autofocus> + </button>
    </div>
</div>

<div class="card" id="detailCard">
    <h1>Person Detail</h1>

    <div class="holder" id="detailContainer">
    </div>
</div>

<section>
    <h2>Play!</h2>
    <p> Have a go and play around with adding new entries, selecting various ones, start typing in either
        the master or the detail view, delete entries, and change the lastname to less than three characters.
        See what happens.
    </p>
    <h2>Multi-Way Editing and Instant Updates</h2>
    <p> Whether you edit in the master or in the detail view, all entries are immediately synchronized.
    </p>
    <p> When there is no selection, the detail view folds away, becomes read-only, and shows no values.
        It makes absolutely no difference what led to the deselection.
        We have chosen to deselect on every delete, such that we can show this effect more easily.
        In a real application, we would of course rather select the next entry than dropping the selection.
    </p>
    <p> Kolibri makes multi-way editing and other consistent updates throughout the application
        very easy. You just define what your attribute represents by giving it a qualifier.
        Kolibri takes care that all attributes with the same qualifier are always kept in sync.
        This applies not only to their values but to all of their properties (validity, label,
        editable, and so on).
    </p>
    <p> Please note that this feature works without any dependencies. No view knows any other view -
        nor do the models! We can add, remove, or modify any part of the application without touching
        the other parts and the synchronization still works!
    </p>
    <h2>Business Rules</h2>
    <p> The lastname attributes have a converter to uppercase and a validator for at least three characters.
        No matter where and how you change, these rules are always enforced and apply wherever the
        same value occurs. The visualization of validation errors is also consistent.
    </p>
    <h2>Master-Detail Views as Projectors</h2>
    <p> Master-Detail Views come in an abundance of different ways.
    </p>
    <p> Here we have a list or table as the master view and a form as a detail view.
        Other master-detail views might be less obvious like a tabbed view where the tabs
        constitute the master. Then there are drop-downs, selections, radio buttons, ribbons,
        accordions, menus, cover-flows, tiles, and so on. The list is endless.
    </p>
    <p> The Kolibri approach is always the same, no matter which of the many master-detail views we encounter.
        We bind the selection to a presentation model. This is so repetitive that we can delegate the
        work to a projector of our preference. In this case we have chosen the "instant-update" projector.
    </p>


</section>



<script src="starter.js" type="module"></script>

</body>

</html>
